<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Isolation (Hex)</title>
<style>
:root {
  --bg: #0a0f24;
  --panel: #102040;
  --accent1: #ffb347;
  --accent2: #3dfaff;
  --player1: #ff7b00;
  --player2: #00ff7f;
  --blocked: #888;
  --cell: #224477;
  --cell-bright: #3377aa;
  --glow1: 0 0 15px 4px rgba(255, 160, 50, 0.8);
  --glow2: 0 0 15px 4px rgba(0, 255, 127, 0.8);
}

html, body {
  height: 100%;
  margin: 0;
  font-family: system-ui, sans-serif;
  background: linear-gradient(180deg, #071020, #101e35);
  color: #eee;
  display: flex;
  flex-direction: column;
  align-items: center;
}

h1 {
  margin: 12px;
  text-align: center;
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-bottom: 10px;
}

button {
  background: var(--panel);
  border: 1px solid #fff2;
  color: inherit;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: 0.15s;
}

button:hover {
  background: #1b2d55;
}

.status {
  margin-top: 10px;
  font-weight: 600;
}

svg {
  background: radial-gradient(circle at 50% 50%, #223355, #111a2f);
  border-radius: 12px;
  box-shadow: 0 0 12px #000a;
}

.hex {
  fill: var(--cell);
  stroke: #0005;
  stroke-width: 1;
  transition: 0.2s;
}

.hex:hover {
  fill: var(--cell-bright);
  stroke: #fff4;
}

.blocked {
  fill: var(--blocked);
  opacity: 0.4;
}

.pawn1, .pawn2 {
  transition: 0.25s;
}

.active1 {
  filter: drop-shadow(var(--glow1));
  animation: pulse1 1s ease-in-out infinite alternate;
}

.active2 {
  filter: drop-shadow(var(--glow2));
  animation: pulse2 1s ease-in-out infinite alternate;
}

@keyframes pulse1 {
  from { filter: drop-shadow(0 0 6px rgba(255,160,50,0.6)); }
  to { filter: drop-shadow(0 0 18px rgba(255,160,50,1)); }
}

@keyframes pulse2 {
  from { filter: drop-shadow(0 0 6px rgba(0,255,127,0.6)); }
  to { filter: drop-shadow(0 0 18px rgba(0,255,127,1)); }
}
</style>
</head>
<body>

<h1>Isolation (Hex)</h1>
<div class="controls">
  <button id="reset">Reset</button>
  <button id="undo">Undo</button>
</div>
<div class="status" id="statusText">Player 1’s turn — Move</div>

<svg id="board" width="700" height="600"></svg>

<script>
const svg = document.getElementById("board");
const radius = 4;
const size = 40;
const origin = {x: 350, y: 300};
const tiles = new Map();
let p1 = {q:0,r:0}, p2 = {q:0,r:0};
let turn = 1;
let phase = "move"; // "move" or "explode"
let blocked = new Set();
let history = [];

function hexToPixel(q, r) {
  const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r) + origin.x;
  const y = size * (3/2 * r) + origin.y;
  return {x, y};
}

function drawHex(q, r) {
  const {x, y} = hexToPixel(q, r);
  let points = "";
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI/3 * i + Math.PI/6;
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    points += `${px},${py} `;
  }
  const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
  poly.setAttribute("points", points.trim());
  poly.classList.add("hex");
  poly.dataset.q = q;
  poly.dataset.r = r;
  poly.addEventListener("click", () => onCellClick(q, r));
  svg.appendChild(poly);
  tiles.set(`${q},${r}`, {q, r, poly});
}

for (let q = -radius; q <= radius; q++) {
  for (let r = -radius; r <= radius; r++) {
    if (Math.abs(q + r) <= radius) drawHex(q, r);
  }
}

function makePawn(color) {
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("r", size * 0.4);
  circle.setAttribute("fill", color);
  svg.appendChild(circle);
  return circle;
}

const pawn1 = makePawn(getComputedStyle(document.documentElement).getPropertyValue("--player1"));
const pawn2 = makePawn(getComputedStyle(document.documentElement).getPropertyValue("--player2"));

function setPawnPos(pawn, q, r) {
  const {x, y} = hexToPixel(q, r);
  pawn.setAttribute("cx", x);
  pawn.setAttribute("cy", y);
}

function resetGame() {
  blocked.clear();
  tiles.forEach(t => t.poly.classList.remove("blocked"));
  p1 = {q: 0, r: 0};
  p2 = {q: 2, r: -2};
  turn = 1;
  phase = "move";
  history = [];
  setPawnPos(pawn1, p1.q, p1.r);
  setPawnPos(pawn2, p2.q, p2.r);
  updateGlow();
  updateStatus();
}

function updateGlow() {
  pawn1.classList.remove("active1", "active2");
  pawn2.classList.remove("active1", "active2");
  if (turn === 1) pawn1.classList.add("active1");
  else pawn2.classList.add("active2");
}

function updateStatus() {
  const phaseText = phase === "move" ? "Move" : "Choose cell to destroy";
  document.getElementById("statusText").textContent =
    `Player ${turn}’s turn — ${phaseText}`;
}

function isBlocked(q, r) {
  return blocked.has(`${q},${r}`);
}

function validMoves(q, r) {
  const dirs = [
    [1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]
  ];
  const moves = [];
  for (const [dq, dr] of dirs) {
    const nq = q + dq, nr = r + dr;
    if (tiles.has(`${nq},${nr}`) && !isBlocked(nq,nr) &&
        !(p1.q===nq && p1.r===nr) && !(p2.q===nq && p2.r===nr)) {
      moves.push({q:nq,r:nr});
    }
  }
  return moves;
}

function onCellClick(q, r) {
  const current = turn === 1 ? p1 : p2;
  const opponent = turn === 1 ? p2 : p1;

  if (phase === "move") {
    const moves = validMoves(current.q, current.r);
    if (!moves.some(m => m.q === q && m.r === r)) return;

    history.push({moveFrom:{q: current.q, r: current.r}, moveTo:{q, r}, blocked:null, turn});
    current.q = q; current.r = r;
    setPawnPos(turn === 1 ? pawn1 : pawn2, q, r);

    phase = "explode";
    updateStatus();

  } else if (phase === "explode") {
    if (isBlocked(q, r) || (p1.q===q && p1.r===r) || (p2.q===q && p2.r===r)) return;

    blocked.add(`${q},${r}`);
    tiles.get(`${q},${r}`).poly.classList.add("blocked");

    // record explosion
    history[history.length-1].blocked = {q, r};

    const oppMoves = validMoves(opponent.q, opponent.r);
    if (oppMoves.length === 0) {
      document.getElementById("statusText").textContent =
        `Player ${turn} wins!`;
      phase = "done";
      return;
    }

    turn = turn === 1 ? 2 : 1;
    phase = "move";
    updateGlow();
    updateStatus();
  }
}

document.getElementById("reset").onclick = resetGame;

document.getElementById("undo").onclick = () => {
  if (!history.length) return;
  const last = history.pop();

  // Unblock exploded cell if any
  if (last.blocked) {
    blocked.delete(`${last.blocked.q},${last.blocked.r}`);
    tiles.get(`${last.blocked.q},${last.blocked.r}`).poly.classList.remove("blocked");
  }

  // Restore pawn position
  const pawn = last.turn === 1 ? pawn1 : pawn2;
  const player = last.turn === 1 ? p1 : p2;
  player.q = last.moveFrom.q;
  player.r = last.moveFrom.r;
  setPawnPos(pawn, player.q, player.r);

  turn = last.turn;
  phase = "move";
  updateGlow();
  updateStatus();
};

resetGame();
</script>

</body>
</html>
