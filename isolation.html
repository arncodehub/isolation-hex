<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Isolation (Hex)</title>
  <style>
    :root {
      --bg: #0a0f24;
      --panel: #102040;
      --accent1: #ffb347;
      --accent2: #3dfaff;
      --player1: #ff7b00;
      --player2: #00ff7f;
      --blocked: #888;
      --cell: #224477;
      --cell-bright: #3377aa;
      --glow1: 0 0 15px 4px rgba(255, 160, 50, 0.8);
      --glow2: 0 0 15px 4px rgba(0, 255, 127, 0.8);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, sans-serif;
      background: linear-gradient(180deg, #071020, #101e35);
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      margin: 12px;
      text-align: center;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 10px;
    }

    button,
    select {
      background: var(--panel);
      border: 1px solid #fff2;
      color: inherit;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: 0.15s;
    }

    button:hover,
    select:hover {
      background: #1b2d55;
    }

    .status {
      margin-top: 10px;
      font-weight: 600;
    }

    svg {
      background: radial-gradient(circle at 50% 50%, #223355, #111a2f);
      border-radius: 12px;
      box-shadow: 0 0 12px #000a;
    }

    .hex {
      fill: var(--cell);
      stroke: #0005;
      stroke-width: 1;
      transition: 0.2s;
    }

    .hex:hover {
      fill: var(--cell-bright);
      stroke: #fff4;
    }

    .blocked {
      fill: var(--blocked);
      opacity: 0.4;
    }

    .pawn1,
    .pawn2 {
      transition: 0.25s;
    }

    .active1 {
      filter: drop-shadow(var(--glow1));
      animation: pulse1 1s ease-in-out infinite alternate;
    }

    .active2 {
      filter: drop-shadow(var(--glow2));
      animation: pulse2 1s ease-in-out infinite alternate;
    }

    @keyframes pulse1 {
      from {
        filter: drop-shadow(0 0 6px rgba(255, 160, 50, 0.6));
      }

      to {
        filter: drop-shadow(0 0 18px rgba(255, 160, 50, 1));
      }
    }

    @keyframes pulse2 {
      from {
        filter: drop-shadow(0 0 6px rgba(0, 255, 127, 0.6));
      }

      to {
        filter: drop-shadow(0 0 18px rgba(0, 255, 127, 1));
      }
    }
  </style>
</head>

<body>

  <h1>Isolation (Hex)</h1>
  <div class="controls">
    <button id="reset">Reset</button>
    <button id="undo">Undo</button>
    <select id="player1Type">
      <option value="human">Player 1: Human</option>
      <option value="easy">Player 1: Bot (Easy)</option>
      <option value="normal">Player 1: Bot (Normal)</option>
      <option value="hard">Player 1: Bot (Hard)</option>
    </select>
    <select id="player2Type">
      <option value="human">Player 2: Human</option>
      <option value="easy">Player 2: Bot (Easy)</option>
      <option value="normal">Player 2: Bot (Normal)</option>
      <option value="hard">Player 2: Bot (Hard)</option>
    </select>
  </div>
  <div class="status" id="statusText">Player 1’s turn — Move</div>

  <svg id="board" width="700" height="600"></svg>

  <script>
    const svg = document.getElementById("board");
    const radius = 4;
    const size = 40;
    const origin = { x: 350, y: 300 };
    const tiles = new Map();
    let p1 = { q: 0, r: 0 }, p2 = { q: 0, r: 0 };
    let turn = 1;
    let phase = "move"; // "move" or "explode"
    let blocked = new Set();
    let history = [];
    let botThinking = false;

    function hexToPixel(q, r) {
      const x = size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + origin.x;
      const y = size * (3 / 2 * r) + origin.y;
      return { x, y };
    }

    function drawHex(q, r) {
      const { x, y } = hexToPixel(q, r);
      let points = "";
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i + Math.PI / 6;
        const px = x + size * Math.cos(angle);
        const py = y + size * Math.sin(angle);
        points += `${px},${py} `;
      }
      const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      poly.setAttribute("points", points.trim());
      poly.classList.add("hex");
      poly.dataset.q = q;
      poly.dataset.r = r;
      poly.addEventListener("click", () => onCellClick(q, r));
      svg.appendChild(poly);
      tiles.set(`${q},${r}`, { q, r, poly });
    }

    for (let q = -radius; q <= radius; q++) {
      for (let r = -radius; r <= radius; r++) {
        if (Math.abs(q + r) <= radius) drawHex(q, r);
      }
    }

    function makePawn(color) {
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("r", size * 0.4);
      circle.setAttribute("fill", color);
      svg.appendChild(circle);
      return circle;
    }

    const pawn1 = makePawn(getComputedStyle(document.documentElement).getPropertyValue("--player1"));
    const pawn2 = makePawn(getComputedStyle(document.documentElement).getPropertyValue("--player2"));

    function setPawnPos(pawn, q, r) {
      const { x, y } = hexToPixel(q, r);
      pawn.setAttribute("cx", x);
      pawn.setAttribute("cy", y);
    }

    // Bot System
    function isBot(player) {
      const select = document.getElementById(`player${player}Type`);
      return select.value !== "human";
    }

    function getBotDifficulty(player) {
      const select = document.getElementById(`player${player}Type`);
      return select.value;
    }

    function botMove() {
      if (botThinking || phase === "done") return;

      botThinking = true;
      const difficulty = getBotDifficulty(turn);

      document.getElementById("statusText").textContent =
        `Player ${turn} (Bot) is thinking...`;

      setTimeout(() => {
        let move;

        if (phase === "move") {
          move = getBotMove(difficulty);
          if (move) {
            makeMove(move.q, move.r);
          }
        } else if (phase === "explode") {
          move = getBotExplosion(difficulty);
          if (move) {
            explodeCell(move.q, move.r);
          }
        }

        botThinking = false;
      }, difficulty === "easy" ? 200 : difficulty === "normal" ? 500 : 1500);
    }

    function getBotMove(difficulty) {
      const current = turn === 1 ? p1 : p2;
      const moves = validMoves(current.q, current.r);

      if (moves.length === 0) return null;

      if (difficulty === "easy") {
        return moves[Math.floor(Math.random() * moves.length)];
      }

      // Quick check for moves that immediately threaten opponent
      const opponent = turn === 1 ? p2 : p1;
      for (const move of moves) {
        // Simulate move
        const oldPos = { q: current.q, r: current.r };
        current.q = move.q;
        current.r = move.r;

        // Check if we can win with any explosion
        const explosions = getValidExplosions();
        for (const explosion of explosions) {
          blocked.add(`${explosion.q},${explosion.r}`);
          const oppMoves = validMoves(opponent.q, opponent.r);
          blocked.delete(`${explosion.q},${explosion.r}`);

          if (oppMoves.length === 0) {
            // Restore position
            current.q = oldPos.q;
            current.r = oldPos.r;
            return move; // This move leads to immediate win!
          }
        }

        // Restore position
        current.q = oldPos.q;
        current.r = oldPos.r;
      }

      const depth = difficulty === "normal" ? 3 : 5;
      return minimax(true, depth, -Infinity, Infinity).move;
    }

    function getBotExplosion(difficulty) {
      const explosions = getValidExplosions();

      if (explosions.length === 0) return null;

      if (difficulty === "easy") {
        return explosions[Math.floor(Math.random() * explosions.length)];
      }

      // First check for immediate winning moves
      const opponent = turn === 1 ? p2 : p1;
      for (const explosion of explosions) {
        // Simulate explosion
        blocked.add(`${explosion.q},${explosion.r}`);
        const oppMoves = validMoves(opponent.q, opponent.r);
        blocked.delete(`${explosion.q},${explosion.r}`);

        if (oppMoves.length === 0) {
          return explosion; // Immediate win!
        }
      }

      const depth = difficulty === "normal" ? 2 : 4;
      return minimaxExplosion(true, depth, -Infinity, Infinity).explosion;
    }

    function getValidExplosions() {
      const explosions = [];
      tiles.forEach((tile, key) => {
        const [q, r] = key.split(',').map(Number);
        if (!isBlocked(q, r) && !(p1.q === q && p1.r === r) && !(p2.q === q && p2.r === r)) {
          explosions.push({ q, r });
        }
      });
      return explosions;
    }

    // Minimax for move phase
    function minimax(isMaximizing, depth, alpha, beta) {
      if (depth === 0) {
        return { score: evaluatePosition(), move: null };
      }

      const currentPlayer = isMaximizing ? turn : (turn === 1 ? 2 : 1);
      const current = currentPlayer === 1 ? p1 : p2;
      const moves = validMoves(current.q, current.r);

      if (moves.length === 0) {
        return { score: isMaximizing ? -1000 : 1000, move: null };
      }

      let bestMove = null;
      let bestScore = isMaximizing ? -Infinity : Infinity;

      for (const move of moves) {
        // Simulate move
        const oldPos = { q: current.q, r: current.r };
        current.q = move.q;
        current.r = move.r;

        // Evaluate explosion phase
        const explosionResult = minimaxExplosion(!isMaximizing, depth - 1, alpha, beta);
        let score = explosionResult.score;

        // Restore position
        current.q = oldPos.q;
        current.r = oldPos.r;

        if (isMaximizing) {
          if (score > bestScore) {
            bestScore = score;
            bestMove = move;
          }
          alpha = Math.max(alpha, score);
        } else {
          if (score < bestScore) {
            bestScore = score;
            bestMove = move;
          }
          beta = Math.min(beta, score);
        }

        if (beta <= alpha) break;
      }

      return { score: bestScore, move: bestMove };
    }

    // Minimax for explosion phase
    function minimaxExplosion(isMaximizing, depth, alpha, beta) {
      const explosions = getValidExplosions();

      if (explosions.length === 0) {
        return { score: evaluatePosition(), explosion: null };
      }

      let bestExplosion = null;
      let bestScore = isMaximizing ? -Infinity : Infinity;
      let winningMoves = [];
      let blockingMoves = [];

      // First pass: identify winning and critical blocking moves
      const nextPlayer = turn === 1 ? 2 : 1;
      const opponent = nextPlayer === 1 ? p1 : p2;

      for (const explosion of explosions) {
        // Simulate explosion
        const wasBlocked = blocked.has(`${explosion.q},${explosion.r}`);
        blocked.add(`${explosion.q},${explosion.r}`);

        const oppMoves = validMoves(opponent.q, opponent.r);

        if (oppMoves.length === 0) {
          // This explosion wins the game immediately
          winningMoves.push(explosion);
        } else if (oppMoves.length === 1) {
          // Opponent down to 1 move - this is critical
          blockingMoves.push({ explosion, oppMoves: oppMoves.length });
        }

        // Restore explosion
        if (!wasBlocked) {
          blocked.delete(`${explosion.q},${explosion.r}`);
        }
      }

      // If we have winning moves, pick the first one
      if (winningMoves.length > 0) {
        return { score: isMaximizing ? 10000 : -10000, explosion: winningMoves[0] };
      }

      // Prioritize moves that reduce opponent to very few options
      if (blockingMoves.length > 0 && depth <= 2) {
        blockingMoves.sort((a, b) => a.oppMoves - b.oppMoves);
        return { score: isMaximizing ? 500 : -500, explosion: blockingMoves[0].explosion };
      }

      // Regular minimax evaluation
      for (const explosion of explosions) {
        // Simulate explosion
        const wasBlocked = blocked.has(`${explosion.q},${explosion.r}`);
        blocked.add(`${explosion.q},${explosion.r}`);

        const oppMoves = validMoves(opponent.q, opponent.r);

        let score;
        if (oppMoves.length === 0) {
          // Game over, current player wins
          score = isMaximizing ? 10000 : -10000;
        } else if (depth === 0) {
          score = evaluatePosition();
        } else {
          // Continue with opponent's turn
          const oldTurn = turn;
          turn = nextPlayer;
          const result = minimax(!isMaximizing, depth - 1, alpha, beta);
          score = result.score;
          turn = oldTurn;
        }

        // Restore explosion
        if (!wasBlocked) {
          blocked.delete(`${explosion.q},${explosion.r}`);
        }

        if (isMaximizing) {
          if (score > bestScore) {
            bestScore = score;
            bestExplosion = explosion;
          }
          alpha = Math.max(alpha, score);
        } else {
          if (score < bestScore) {
            bestScore = score;
            bestExplosion = explosion;
          }
          beta = Math.min(beta, score);
        }

        if (beta <= alpha) break;
      }

      return { score: bestScore, explosion: bestExplosion };
    }

    function evaluatePosition() {
      const p1Moves = validMoves(p1.q, p1.r).length;
      const p2Moves = validMoves(p2.q, p2.r).length;

      // Terminal positions
      if (p1Moves === 0) return -10000;
      if (p2Moves === 0) return 10000;

      // Critical positions - heavily weight low mobility
      let mobilityScore = 0;
      if (p1Moves === 1) mobilityScore -= 200;
      else if (p1Moves === 2) mobilityScore -= 50;

      if (p2Moves === 1) mobilityScore += 200;
      else if (p2Moves === 2) mobilityScore += 50;

      // General mobility advantage
      mobilityScore += (p1Moves - p2Moves) * 15;

      // Center control bonus (less important than mobility)
      const p1Center = Math.abs(p1.q) + Math.abs(p1.r) + Math.abs(p1.q + p1.r);
      const p2Center = Math.abs(p2.q) + Math.abs(p2.r) + Math.abs(p2.q + p2.r);
      const centerScore = (p2Center - p1Center) * 3;

      // Adjust score based on whose turn it is
      const totalScore = mobilityScore + centerScore;
      return turn === 1 ? totalScore : -totalScore;
    }

    function resetGame() {
      blocked.clear();
      tiles.forEach(t => t.poly.classList.remove("blocked"));
      p1 = { q: 0, r: 0 };
      p2 = { q: 2, r: -2 };
      turn = 1;
      phase = "move";
      history = [];
      botThinking = false;
      setPawnPos(pawn1, p1.q, p1.r);
      setPawnPos(pawn2, p2.q, p2.r);
      updateGlow();
      updateStatus();

      // Start bot if player 1 is bot
      setTimeout(() => {
        if (isBot(1) && phase === "move") {
          botMove();
        }
      }, 500);
    }

    function updateGlow() {
      pawn1.classList.remove("active1", "active2");
      pawn2.classList.remove("active1", "active2");
      if (turn === 1) pawn1.classList.add("active1");
      else pawn2.classList.add("active2");
    }

    function updateStatus() {
      const phaseText = phase === "move" ? "Move" : "Choose cell to destroy";
      document.getElementById("statusText").textContent =
        `Player ${turn}’s turn — ${phaseText}`;
    }

    function isBlocked(q, r) {
      return blocked.has(`${q},${r}`);
    }

    function validMoves(q, r) {
      const dirs = [
        [1, 0], [1, -1], [0, -1], [-1, 0], [-1, 1], [0, 1]
      ];
      const moves = [];
      for (const [dq, dr] of dirs) {
        const nq = q + dq, nr = r + dr;
        if (tiles.has(`${nq},${nr}`) && !isBlocked(nq, nr) &&
          !(p1.q === nq && p1.r === nr) && !(p2.q === nq && p2.r === nr)) {
          moves.push({ q: nq, r: nr });
        }
      }
      return moves;
    }

    function onCellClick(q, r) {
      if (botThinking) return;

      const current = turn === 1 ? p1 : p2;
      const opponent = turn === 1 ? p2 : p1;

      if (phase === "move") {
        const moves = validMoves(current.q, current.r);
        if (!moves.some(m => m.q === q && m.r === r)) return;

        makeMove(q, r);

      } else if (phase === "explode") {
        if (isBlocked(q, r) || (p1.q === q && p1.r === r) || (p2.q === q && p2.r === r)) return;

        explodeCell(q, r);
      }
    }

    function makeMove(q, r) {
      const current = turn === 1 ? p1 : p2;

      history.push({ moveFrom: { q: current.q, r: current.r }, moveTo: { q, r }, blocked: null, turn });
      current.q = q; current.r = r;
      setPawnPos(turn === 1 ? pawn1 : pawn2, q, r);

      phase = "explode";
      updateStatus();

      // Check if current player is bot for explosion phase
      setTimeout(() => {
        if (isBot(turn) && phase === "explode") {
          botMove();
        }
      }, 100);
    }

    function explodeCell(q, r) {
      const opponent = turn === 1 ? p2 : p1;

      blocked.add(`${q},${r}`);
      tiles.get(`${q},${r}`).poly.classList.add("blocked");

      // record explosion
      history[history.length - 1].blocked = { q, r };

      const oppMoves = validMoves(opponent.q, opponent.r);
      if (oppMoves.length === 0) {
        document.getElementById("statusText").textContent =
          `Player ${turn} wins!`;
        phase = "done";
        return;
      }

      turn = turn === 1 ? 2 : 1;
      phase = "move";
      updateGlow();
      updateStatus();

      // Check if next player is bot
      setTimeout(() => {
        if (isBot(turn) && phase === "move") {
          botMove();
        }
      }, 300);
    }

    document.getElementById("reset").onclick = resetGame;

    document.getElementById("undo").onclick = () => {
      if (!history.length || botThinking) return;
      const last = history.pop();

      // Unblock exploded cell if any
      if (last.blocked) {
        blocked.delete(`${last.blocked.q},${last.blocked.r}`);
        tiles.get(`${last.blocked.q},${last.blocked.r}`).poly.classList.remove("blocked");
      }

      // Restore pawn position
      const pawn = last.turn === 1 ? pawn1 : pawn2;
      const player = last.turn === 1 ? p1 : p2;
      player.q = last.moveFrom.q;
      player.r = last.moveFrom.r;
      setPawnPos(pawn, player.q, player.r);

      turn = last.turn;
      phase = "move";
      botThinking = false;
      updateGlow();
      updateStatus();
    };

    // Bot selection event listeners
    document.getElementById("player1Type").onchange = () => {
      if (turn === 1 && phase === "move" && isBot(1)) {
        setTimeout(() => botMove(), 300);
      }
    };

    document.getElementById("player2Type").onchange = () => {
      if (turn === 2 && phase === "move" && isBot(2)) {
        setTimeout(() => botMove(), 300);
      }
    };

    resetGame();
  </script>

</body>

</html>